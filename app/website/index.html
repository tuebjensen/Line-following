<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Line following robot configurator</title>
<style>
    body {
        margin: 0;
        background: #eee;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }
    .container {
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
    }
    header {
        overflow: auto;
        box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
    }
    section {
        margin: 3em 0;
    }
    textarea {
        width: 100%;
        height: 200px;
        resize: vertical;
        box-sizing: border-box;
    }
    svg {
        background: white;
        border: 1px solid grey;
        border-radius: 4px;
    }
    text {
        fill: white;
        font-size: 8px;
    }
    text.central {
        font-size: 14px;
    }
    line {
        stroke: rgba(0, 100, 255, 0.5);
    }
    circle {
        fill: rgba(50, 0, 0, 0.7)
    }
</style>

<header>
    <div class="container">
        <h1>Line following robot configurator</h1>
    </div>
</header>

<section class="container">
    <h2>Instructions</h2>
    <ul>
        <li>
            To make the robot go to an intersection, click on its node.
            The strong blue lines show the optimal path,
            the green line shows the path the robot is on,
            and the green node shows the last visited node.
        </li>
    </ul>
</section>

<section class="container">
    <h2>The graph of the map</h2>
    <svg></svg>
</section>

<section class="container">
    <h2>Update the map</h2>
    <form>
        <textarea></textarea>
        <p>
            <button>Update</button>
        </p>
    </form>
</section>
<!--
    <img src="/video-feed" width="100%">
-->

<script type="module">
    import * as d3 from 'https://cdn.skypack.dev/pin/d3@v7.6.1-1Q0NZ0WZnbYeSjDusJT3/mode=imports,min/optimized/d3.js'
    import forceBoundary from 'https://cdn.skypack.dev/-/d3-force-boundary@v0.0.3-IAIjk85RWFsumozhSBoe/dist=es2019,mode=imports/optimized/d3-force-boundary.js'

    // A simplified implementation of RxJs's BehaviorSubject.
    class BehaviorSubject {
        listeners = new Set()
        constructor (value) {
            super()
            this._value = value
        }
        get value () {
            return this._value
        }
        next (value) {
            this._value = value
            for (const listener of this.listeners) {
                listener(value)
            }
        }
        subscribe (listener) {
            this.listeners.add(listener)
            listener(this._value)
            return {
                unsubscribe: () => {
                    this.listeners.delete(listener)
                }
            }
        }
    }

    // Connect to Websocket and manage the state subject
    const state = new BehaviorSubject(null)

    function connectToWebsocket () {
        const socket = new WebSocket('ws://' + location.host + '/ws')

        socket.onmessage = (e) => {
            try {
                const { type, data } = JSON.parse(e.data)
                if (type === 'update') {
                    state.next(data)
                } else if (type === 'request-update') {
                    socket.send(JSON.stringify({
                        type: 'update',
                        data: state.value
                    }))
                }
            } catch (err) {
                console.error(err)
            }
        }

        let subscription = null
        socket.onopen = () => {
            subscription = state.subscribe((value) => {
                socket.send(JSON.stringify({
                    type: 'update',
                    data: state.value
                }))
            })
        }

        socket.onclose = () => {
            subscription.unsubscribe()
            setTimeout(() => {
                connectToWebsocket()
            }, 3000)
        }

        socket.onerror = (err) => {
            console.error('Error in websocket', err)
            socket.close()
        }
    }
    connectToWebsocket()

    // Setup D3
    const nodeRadius = 20
    const nodeDistance = 50

    const graph = {
        nodes: [
            { id: 'A' },
            { id: 'B' },
            { id: 'C' },
            { id: 'D' },
            { id: 'E' },
            { id: 'F' },
            { id: 'G' },
            { id: 'H' }
        ],
        links: [
            { source: 'A', sourcePos: 'e', target: 'B', targetPos: 'w' },
            { source: 'A', sourcePos: 's', target: 'C', targetPos: 'n' },
            { source: 'B', sourcePos: 's', target: 'D', targetPos: 'n' },
            { source: 'C', sourcePos: 'e', target: 'D', targetPos: 'w' },
            { source: 'C', sourcePos: 's', target: 'F', targetPos: 'n' },
            { source: 'D', sourcePos: 'e', target: 'E', targetPos: 'w' },
            { source: 'D', sourcePos: 's', target: 'G', targetPos: 'n' },
            { source: 'E', sourcePos: 's', target: 'H', targetPos: 'n' },
            { source: 'F', sourcePos: 'e', target: 'G', targetPos: 'w' },
            { source: 'G', sourcePos: 'e', target: 'H', targetPos: 'w' },
        ]
    }

    const width = 50 * Math.ceil(Math.sqrt(graph.nodes.length)) + nodeRadius * 2
    const height = width

    for (const { source, sourcePos, target } of graph.links.map(link => [
        link,
        {
            source: link.target,
            sourcePos: link.targetPos,
            target: link.source,
            targetPos: link.sourcePos
        }
    ]).flat()) {
        const node = graph.nodes.find(node => node.id === source)
        if (!node) {
            throw new Error('Linking to nonexistent node!')
        }
        if (node[sourcePos]) {
            throw new Error('Duplicate linking to the same position of the node!')
        }
        node[sourcePos] = target
    }

    const svg = d3.select('svg').attr("viewBox", [0, 0, width, height])

    const link = svg
        .selectAll(".link")
        .data(graph.links)
        .join("line")
        .classed("link", true)

    const node = svg
        .selectAll(".node")
        .data(graph.nodes)
        .join('g')
        .classed("node", true)
    
    node
        .append('circle')
        .attr("r", nodeRadius)
    
    for (const { text, pos, classes } of [{
        text: d => d.id,
        classes: 'central'
    }/*, {
        text: d => d.n,
        pos: [0, -12]
    }, {
        text: d => d.e,
        pos: [12, 0]
    }, {
        text: d => d.s,
        pos: [0, 12]
    }, {
        text: d => d.w,
        pos: [-12, 0]
    }*/]) {
        node
            .append('text')
            .attr('dominant-baseline', "middle")
            .attr('text-anchor', 'middle')
            .attr('x', pos?.[0])
            .attr('y', pos?.[1])
            .attr('class', classes)
            .text(text)
    }

    const simulation = d3
        .forceSimulation()
        .nodes(graph.nodes)
        .force('charge', d3.forceManyBody().strength(-100))

        .force('top', d3.forceY(0)
            .strength(node => !node.n ? 0.1 : 0))
        .force('right', d3.forceX(width)
            .strength(node => !node.e ? 0.1 : 0))
        .force('bottom', d3.forceY(height)
            .strength(node => !node.s ? 0.1 : 0))
        .force('left', d3.forceX(0)
            .strength(node => !node.w ? 0.1 : 0))

        .force('boundary', forceBoundary(0 + nodeRadius, 0 + nodeRadius, width - nodeRadius, height - nodeRadius)
            .border(nodeRadius))
        .force('link', d3.forceLink(graph.links)
            .id(node => node.id)
            .distance(() => nodeDistance))
        .on('tick', tick);

    node.on('click', click);

    function tick() {
        link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);
        node
            .attr("transform", d => `translate(${d.x}, ${d.y})`)
    }

    function click(event, d) {
        // TODO make path and visualize it
        console.log(event, d)
    }

    // TODO handle map update
</script>
