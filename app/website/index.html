<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Line following robot configurator</title>
<style>
    body {
        margin: 0;
        background: #eee;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }
    .container {
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
    }
    header {
        overflow: auto;
        box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
    }
    section {
        margin: 3em 0;
    }
    textarea {
        width: 100%;
        height: 200px;
        resize: vertical;
        box-sizing: border-box;
    }
    svg {
        background: white;
        border: 1px solid grey;
        border-radius: 4px;
    }
    .node:hover {
        opacity: 0.8;
        cursor: pointer;
    }
    text {
        fill: white;
        font-size: 14px;
    }
    line {
        stroke: rgba(0, 100, 255, 0.5);
    }
    circle {
        fill: rgba(50, 0, 0, 0.7)
    }
</style>

<header>
    <div class="container">
        <h1>Line following robot configurator</h1>
    </div>
</header>

<section class="container">
    <h2>Instructions</h2>
    <ul>
        <li>
            To make the robot go to an intersection, click on its node.
            The strong blue lines show the optimal path,
            the green line shows the path the robot is on,
            and the green node shows the last visited node.
        </li>
    </ul>
</section>

<section class="container">
    <h2>The graph of the map</h2>
    <svg></svg>
</section>

<section class="container">
    <h2>Update the map</h2>
    <form id="map-update-form">
        <textarea id="map-input"></textarea>
        <p>
            <button>Update</button>
        </p>
    </form>
</section>
<!--
    <img src="/video-feed" width="100%">
-->

<script type="module">
    import * as d3 from 'https://cdn.skypack.dev/pin/d3@v7.6.1-1Q0NZ0WZnbYeSjDusJT3/mode=imports,min/optimized/d3.js'
    import forceBoundary from 'https://cdn.skypack.dev/-/d3-force-boundary@v0.0.3-IAIjk85RWFsumozhSBoe/dist=es2019,mode=imports/optimized/d3-force-boundary.js'
    import { BehaviorSubject, fromEvent, Observable, concatWith, mergeMap, switchMap, of, tap, throwError, retry, map, filter, merge, share, combineLatest } from 'https://cdn.skypack.dev/pin/rxjs@v7.5.7-j3yWv9lQY9gNeD9CyX5Y/mode=imports,min/optimized/rxjs.js'
    //import {  } from 'https://cdn.skypack.dev/pin/rxjs@v7.5.7-j3yWv9lQY9gNeD9CyX5Y/mode=imports,min/optimized/rxjs/operators.js'

    // Handle WebSocket streams
    const { clientState$, serverState$, updateClientState } = (function(){

        /**
         * The stream of websockets.
         * A new socket is created every time a socket closes or errors.
         */
        const socket$ = new Observable((subscriber) => {
            subscriber.next(
                new WebSocket('ws://' + location.host + '/ws')
            )
        }).pipe(
            switchMap(socket => merge(
                // emit the socket when it becomes open
                fromEvent(socket, 'open').pipe(
                    map(() => socket),
                    tap(() => console.log('websocket opened'))),
                // on the first error, emit null, close the socket, and then throw an error
                fromEvent(socket, 'error').pipe(
                    first(),
                    mergeMap(() =>
                        of(null).pipe(
                            tap(() => {
                                console.log('websocket errored')
                                socket.close()
                            })),
                            concatWith(
                                throwError(() => new Error('WebSocket stream either closed or had an error!'))))),
                // emit null if the socket is closed
                fromEvent(socket, 'close').pipe(
                    tap(() => console.log('websocket closed')),
                    map(() => null)))),
            retry({
                delay: 3000
            }),
            share())
        
        socket$.subscribe(s => console.log('socket', s))
    
        /**
         * Stream of parsed messages coming from the sockets.
         */
        const message$ = socket$.pipe(
            mergeMap(socket => fromEvent(socket, 'message')),
            map(JSON.parse),
            share())
        
        message$.subscribe(m => console.log('message', m))

        /**
         * Stream which includes updates coming from the sockets targeting both client and server states.
         * The stream normally outputs
         *   1. Right after the connection has been made
         *   2. When the connection closes
         */
        const fullStateUpdate$ = merge(
            message$.pipe(
                filter(({ type, data }) => type === 'full-state-update'),
                map(message => message.data)),
            socket$.pipe(
                filter(socket => socket === null),
                map(() => ({
                    clientState: null,
                    serverState: null
                })))
        ).pipe(
            share())

        /**
         * Stream which includes updates coming from the sockets targeting the server state.
         * The stream outputs often, e.g. when the Raspberry Pi leaves a node.
         * Outputs null when the socket is closed.
         */
        const serverStateUpdate$ = merge(
            fullStateUpdate$.pipe(
                map(data => data.serverState)),
            message$.pipe(
                filter(message => message.type === 'server-state-update'),
                map(message => message.data))
        ).pipe(
            share())

        /**
         * Stream which includes updates coming from the sockets targeting the client state. 
         */
        const clientStateUpdate$ = merge(
            fullStateUpdate$.pipe(
                map(data => data.clientState)
            )
        ).pipe(
            share())

        // make it possible for the client to emit new client state
        const clientStateSubject$ = new BehaviorSubject()
        function updateClientState (clientState) {
            clientStateSubject$.next(clientState)
        }

        // if the client emits new states, send them to the server
        combineLatest([
            clientStateSubject$,
            socket$
        ]).subscribe(([clientState, socket]) => {
            socket?.send(clientState)
        })

        const clientState$ = merge(
            clientStateSubject$,
            clientStateUpdate$
        )

        return {
            updateClientState,
            clientState$,
            serverState$: serverStateUpdate$
        }
    })()

    // Setup D3 & the graph visualization.
    ;(function() {

        // one time setup
        const nodeRadius = 20
        const nodeDistance = 50
    
        const svg = d3.select('svg')
        
        const simulation = d3
            .forceSimulation()
            .force('charge', d3.forceManyBody().strength(-100))
            .force('top', d3.forceY(0)
                .strength(node => !node.n ? 0.1 : 0))
            .force('left', d3.forceX(0)
                .strength(node => !node.w ? 0.1 : 0))        
    

        // setup when user updates the map
        function updateLinks (links) {
            const graph = {
                nodes: [],
                links
            }
    
            // build graph nodes based on the links
            for (const { source, sourcePoint, target } of graph.links.flatMap(link => [
                link,
                {
                    source: link.target,
                    sourcePoint: link.targetPoint,
                    target: link.source,
                    targetPoint: link.sourcePoint
                }
            ])) {
                let node = graph.nodes.find(node => node.id === source)
                if (!node) {
                    // node doesn't exist yet, so create it
                    node = {
                        id: source
                    }
                    graph.nodes.push(node)
                }
                if (node[sourcePoint]) {
                    throw new Error('Duplicate linking to the same position of the node!')
                }
                node[sourcePoint] = target
            }
    
            const width = 50 * Math.ceil(Math.sqrt(graph.nodes.length)) + nodeRadius * 2
            const height = width

            svg.attr('viewBox', [0, 0, width, height])

            const link = svg
                .selectAll('.link')
                .data(graph.links, link => link)
                .join(enter =>
                    enter
                        .append('line')
                        .classed('link' , true))
        
            const node = svg
                .selectAll(".node")
                .data(graph.nodes, node => node.id)
                .join(enter =>
                    enter
                        .append('g')
                        .classed('node', true)
                        .call(g => {
                            g
                                .append('circle')
                                .attr('r', nodeRadius)
                            g
                                .append('text')
                                // center it
                                .attr('dominant-baseline', "middle")
                                .attr('text-anchor', 'middle')
                                // add text
                                .text(data => data.id)
                        }))

            simulation
                .nodes(graph.nodes)

                .force('right', d3.forceX(width)
                    .strength(node => !node.e ? 0.1 : 0))
                .force('bottom', d3.forceY(height)
                    .strength(node => !node.s ? 0.1 : 0))

                .force('boundary', forceBoundary(0 + nodeRadius, 0 + nodeRadius, width - nodeRadius, height - nodeRadius)
                    .border(nodeRadius))

                .force('link', d3.forceLink(graph.links)
                    .id(node => node.id)
                    .distance(() => nodeDistance))

                .on('tick', tick)                    
                .alpha(1)
                .restart()
            
                function tick() {
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
                    node
                        .attr('transform', d => `translate(${d.x}, ${d.y})`)
                }
        }
    
        const defaultLinks = [
            { source: 'A', sourcePoint: 'e', target: 'B', targetPoint: 'w' },
            { source: 'A', sourcePoint: 's', target: 'C', targetPoint: 'n' },
            { source: 'B', sourcePoint: 's', target: 'D', targetPoint: 'n' },
            { source: 'C', sourcePoint: 'e', target: 'D', targetPoint: 'w' },
            { source: 'C', sourcePoint: 's', target: 'F', targetPoint: 'n' },
            { source: 'D', sourcePoint: 'e', target: 'E', targetPoint: 'w' },
            { source: 'D', sourcePoint: 's', target: 'G', targetPoint: 'n' },
            { source: 'E', sourcePoint: 's', target: 'H', targetPoint: 'n' },
            { source: 'F', sourcePoint: 'e', target: 'G', targetPoint: 'w' },
            { source: 'G', sourcePoint: 'e', target: 'H', targetPoint: 'w' },
        ]
        updateLinks(JSON.parse(JSON.stringify(defaultLinks)))

        const mapUpdateForm = document.getElementById('map-update-form')
        const mapInput = document.getElementById('map-input')

        mapInput.value = JSON.stringify(defaultLinks, null, 2)
        mapUpdateForm.addEventListener('submit', (e) => {
            e.preventDefault()
            updateLinks(JSON.parse(mapInput.value))
        })
    })()

    window['updateClientState'] = updateClientState
    clientState$.subscribe((state) => console.log('clientStateUpdated', state))
    serverState$.subscribe((state) => console.log('serverStateUpdated', state))

    // TODO handle map update
</script>
